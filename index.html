<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol Adaptor State Attestation Report</title>
    <style>
        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background-color: #3D2B1F; /* Dark, warm brown */
            color: #F5E8C7; /* Cream / light beige */
            line-height: 1.7;
            margin: 0;
            padding: 0;
        }

       .container {
            max-width: 840px;
            margin: 40px auto;
            padding: 20px 40px;
            background-color: #2F231A; /* Slightly lighter, saturated brown */
            border-radius: 8px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid #5A4434;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 300;
            color: #E67E22; /* Rust orange */
        }

        h1 {
            font-size: 2.5em;
            font-weight: 400;
            border-bottom: 2px solid #D35400; /* Darker orange */
            padding-bottom: 10px;
        }

        h2 {
            font-size: 2em;
            color: #F39C12; /* Golden-yellow */
            margin-top: 2em;
            border-bottom: 1px solid #7a500a;
            padding-bottom: 8px;
        }

        h3 {
            font-size: 1.5em;
            color: #E67E22; /* Rust orange */
            margin-top: 1.8em;
        }

        p, li {
            font-size: 1.1em;
        }

        ul, ol {
            padding-left: 2em;
        }

        a {
            color: #F39C12; /* Golden-yellow */
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        code {
            background-color: #1a1a1a;
            color: #E0B684; /* Light gold */
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Menlo', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #5A4434;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }

        pre code {
            padding: 0;
            background-color: transparent;
            font-size: 0.95em;
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word; /* Break words if necessary */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5em 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        th, td {
            border: 1px solid #5A4434; /* Dark line */
            padding: 12px 15px;
            text-align: left;
        }

        th {
            background-color: #4A3527; /* Medium brown */
            color: #E67E22; /* Rust orange */
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 600;
        }

        tbody tr:nth-child(even) {
            background-color: #382A20; /* Slightly lighter for striping */
        }

        blockquote {
            border-left: 4px solid #E67E22; /* Rust orange */
            padding-left: 1.5em;
            margin: 1.5em 0;
            font-style: italic;
            color: #D2B48C; /* Tan */
        }

        hr {
            border: 0;
            height: 1px;
            background-color: #5A4434;
            margin: 2em 0;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>A Technical Specification for Bidirectional State Attestation Between EVM-based L1 and L2 Protocol Adaptors</h1>

        <h2>Direct Answers to Project Questions</h2>
        <p>Here are the direct answers to your explicit questions, based on the detailed analysis in the report.</p>

        <blockquote>
            <p><strong>Question 1: How does the Ethereum PA check that Base state has changed? How about the other way around?</strong></p>
        </blockquote>
        <p>This is a fundamentally <em>asymmetric</em> relationship.</p>
        <ul>
            <li><strong>L1-to-L2 (Ethereum to Base):</strong> The L2 PA (on Base) <strong>cannot</strong> "check" the L1 PA's state. L2 contracts cannot read the L1 state root.[1, 2] The <em>only</em> secure method is for the L1 PA to <em>send a message</em> to the L2 PA using the native L1-to-L2 bridge (e.g., <code>OptimismPortal</code> [3, 4]). The L2 PA then "endorses" this state change by verifying that the <code>msg.sender</code> is the aliased address of the L1 PA.[5]</li>
            <li><strong>L2-to-L1 (Base to Ethereum):</strong> The L1 PA (on Ethereum) "checks" the L2 PA's state by verifying a proof. This is the "endorsement" process for your GMP, and you have three models to choose from:
                <ol>
                    <li><strong>Model A (Optimistic):</strong> The L1 PA verifies a Merkle-Patricia-Trie (MPT) proof against a <em>finalized</em> L2 state root. It gets this root from the on-chain L1 bridge oracle (the <code>L2OutputOracle</code> contract [3, 6, 4]), which enforces the ~7-day finality (challenge) period.[7, 8]</li>
                    <li><strong>Model B (ZK):</strong> The L1 PA verifies a ZK proof (e.g., from Risc0 [9, 10]) that proves the L2 PA's execution <em>instantly</em>.</li>
                    <li><strong>Model C (Attested):</strong> The L1 PA verifies an attestation from a permissionless solver network. This model is only secure for L2-native resources (where the L1 PA holds no collateral) and can be trust-minimized using ZKPs and TEEs.</li>
                </ol>
            </li>
        </ul>

        <blockquote>
            <p><strong>Question 2: How can I hardcode state attestation? (i.e., provide an algorithm...)</strong></p>
        </blockquote>
        <p>You can "hardcode" state attestation by implementing <strong>Model A (Optimistic)</strong>. The algorithm is a 3-step process detailed in Section 4 of this report:</p>
        <ol>
            <li><strong>Off-Chain: Calculate Storage Slot.</strong> Deterministically calculate the MPT <code>key</code> (the storage slot) of the variable you want to check in the L2 PA contract.[11, 12, 13, 2]</li>
            <li><strong>Off-Chain: Generate Proof.</strong> An off-chain relayer calls <code>eth_getProof</code> [11, 14, 12, 15, 13, 16] on a <em>finalized</em> L2 block to get the <code>storageProof</code> data.</li>
            <li><strong>On-Chain (L1 PA): Verify Proof.</strong> Your L1 PA contract executes the following logic:
                <ul>
                    <li>Fetches the <em>finalized</em> <code>l2StateRoot</code> from the L1 <code>L2OutputOracle</code> contract.[3, 6, 4]</li>
                    <li>Performs the finality check (see Q3).</li>
                    <li>Uses a Solidity MPT verifier library [17, 18, 19, 20, 21, 22, 23] to verify the <code>storageProof</code> against the <code>l2StateRoot</code>.</li>
                    <li><strong>Crucial Security Note:</strong> This verifier <em>must</em> be patched against the "empty proof" vulnerability [24, 25, 26], which can be used to forge proofs.</li>
                </ul>
            </li>
        </ol>

        <blockquote>
            <p><strong>Question 3: Specifically how can we attest to finality?</strong></p>
        </blockquote>
        <p>Finality attestation is different for each model:</p>
        <ul>
            <li><strong>Model A (Optimistic):</strong> Finality is <strong>time-based</strong>. You <em>must</em> check that the L2 state root (from the <code>L2OutputOracle</code>) is older than the ~7-day challenge period.[7, 8] The Solidity check is <code>require(block.timestamp &gt; proposal.timestamp + FINALIZATION_PERIOD_SECONDS)</code>.</li>
            <li><strong>Model B (ZK):</strong> Finality is <strong>instant and mathematical</strong>. The attestation <em>is</em> the successful verification of the ZK proof. A <code>true</code> return from the verifier contract <em>is</em> the proof of finality.[10]</li>
            <li><strong>Model C (Attested):</strong> Finality is <strong>instant and trust-based</strong>. The attestation is the successful verification of the solver's credentials (e.g., their ZK proof of state, their TEE remote attestation, or their simple multisig).</li>
        </ul>

        <blockquote>
            <p><strong>Question 4: How from that state can I deterministically fetch the state of the given PA?</strong></p>
        </blockquote>
        <p>The L1 PA (an on-chain contract) <strong>cannot "fetch"</strong> state. It must be <em>given</em> the state and a proof, which it then verifies.</p>
        <p>The "deterministic" part is how an off-chain relayer <em>finds</em> the state to build the proof. State variables in Solidity are stored at deterministic storage slots.[12, 13]</p>
        <ul>
            <li><strong>For simple variables</strong> (e.g., <code>uint256 public myVar</code> at slot 0), the MPT key is <code>0x00...00</code>.[12, 13]</li>
            <li><strong>For mappings</strong> (e.g., <code>mapping(address => uint) balances</code> at slot 3), the key for <code>balances[0xabc...]</code> is <code>keccak256(abi.encodePacked(0x00...abc..., 0x00...003))</code>.[11, 2]</li>
        </ul>
        <p>Your off-chain relayer uses this deterministic key to call <code>eth_getProof</code> [16] and get the <code>storageProof</code>. This proof is then passed to your L1 PA, which uses the same deterministic key in its <code>verifyStorageProof</code> function.[17, 22]</p>

        <blockquote>
            <p><strong>Question 5:...what is the data availability of the service providing us with state change proofs? e.g. if we use Boundless Signal, what happens if Risc0 version (and hence verification key) changes?</strong></p>
        </blockquote>
        <p>This question correctly identifies two distinct risks of <strong>Model B (ZK)</strong>:</p>
        <ol>
            <li><strong>Data Availability (Boundless Signal):</strong> Boundless is a "proof market".[3, 27, 28, 29] This is a <strong>liveness/service availability risk</strong>, not a DA risk. If the Boundless network fails (e.g., it's unprofitable for provers), new L2 state changes cannot be <em>proven</em>. This would <em>halt</em> your GMP's fast path until a proof can be generated. The system doesn't break, but it freezes.</li>
            <li><strong>Risc0 Version Changes (Verification Key):</strong> This is a critical <strong>centralized governance risk</strong>. The <code>RiscZeroVerifierRouter</code> contract is an upgradeable proxy managed by the Risc0 team.[5, 10] When Risc0 updates its zkVM, it updates this router to point to a new verifier contract.[10, 30]
                <ul>
                    <li><strong>The Risk:</strong> If the Risc0 team's governance keys are compromised, an attacker could point the router to a malicious verifier (e.g., <code>function verify(...) { return true; }</code>). This would allow them to forge any proof and steal all funds from your L1 PA.</li>
                    <li><strong>Mitigation:</strong> Your L1 PA *must not* blindly trust this router. It should <strong>wrap the router</strong> in its own governance (DAO/multisig) and a circuit-breaker. This mechanism would pause all attestations if the router's address changes without your own DAO's explicit approval.[31]</li>
                </ul>
            </li>
        </ol>

        <hr>

        <h2>Executive Summary</h2>
        <p>This report provides a technical specification for achieving provable, bidirectional state attestation between Protocol Adaptors (PAs) deployed on Ethereum (L1), Base (L2), and Arbitrum (L2). The architectural premise is derived from the Anoma protocol's conceptual model of "resources" managed by "controllers," where interoperability is achieved via a process of "endorsement". This analysis translates that academic framework into a practical, EVM-native implementation for our custom General Message Passing (GMP) protocol.</p>
        <p>The core challenge is attesting to <em>finalized</em> state across heterogeneous trust boundaries. The analysis concludes the following:</p>
        <ol>
            <li><strong>L2-to-L1 Attestation is an Endorsement Choice:</strong> For our custom GMP, we must choose an "endorsement" model. This choice depends on <em>what</em> is being bridged:
                <ul>
                    <li><strong>For L1-Native Resources</strong> (where the L1 PA is the "ledger of record"): We <em>must</em> use a trustless model to prevent collateral theft. The primary options are:
                        <ul>
                            <li><strong>Model A (Optimistic):</strong> Trusting the L1 bridge oracle's 7-day finality.[7, 8]</li>
                            <li><strong>Model B (ZK):</strong> Trusting a ZK proof (e.g., Risc0) for instant finality.[9, 10]</li>
                        </ul>
                    </li>
                    <li><strong>For L2-Native Resources</strong> (where the L2 PA is the "ledger of record"): We are free to adopt a <em>sovereign</em> model. This opens a third, more advanced option:
                        <ul>
                            <li><strong>Model C (Attested):</strong> Using a permissionless solver network that attests to the sequencer feed. Trust is minimized by requiring solvers to provide ZKPs of state <em>and</em> run their solving logic inside Trusted Execution Environments (TEEs) like Intel TDX.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>On-Chain vs. Off-Chain Finality:</strong> The L1 PA is an <em>on-chain contract</em>. It cannot run L2 state derivation. It is blind to the "instant" finality available to off-chain nodes. The L1 PA's <em>only</em> trustless, on-chain source of L2 state is the L1 bridge oracle (e.g., <code>L2OutputOracle</code> [3, 6, 4]), which enforces the ~7-day challenge period.[7, 8] This is <strong>Model A</strong>.</li>
            <li><strong>L1-to-L2 Attestation is Asymmetric:</strong> L2 contracts <em>cannot</em> read the L1 state root.[1, 2] Therefore, an L2 PA <em>cannot</em> independently verify L1 state via MPT proofs. The only secure mechanism is for the L1 PA to <em>send</em> its state to the L2 PA via the native L1-to-L2 bridge, where the message's origin is proven by L2's <code>msg.sender</code> aliasing.[32, 5]</li>
            <li><strong>ZK Attestation (Model B) Risk:</strong> Using a ZK proof service like Risc0 to prove <em>L2 PA execution</em> provides instant finality [33, 34, 9] but introduces a critical risk vector: <em>centralized governance</em>. The <code>RiscZeroVerifierRouter</code> contract [5, 10], which validates proofs, is an upgradeable proxy managed by the Risc0 team.[10]</li>
            <li><strong>Fast Bridge Applications (Model C):</strong> A "fast bridge" application, as noted, can be built <em>on top</em> of the core protocol. This service layer (Model C) operates by having off-chain solvers/LPs trust the sequencer feed [29, 35], providing instant liquidity to users, while using the protocol's secure (but slow) <strong>Model A</strong> to rebalance their own funds.[13]</li>
        </ol>
        
        <h2>1. A Framework for Cross-Chain Integrity: From Anoma's Controllers to EVM PAs</h2>
        <h3>1.1 Interpreting the Project Goal through the Anoma Lens</h3>
        <p>The project's architectural context is rooted in the Anoma protocol, a "distributed operating system for intent-centric applications". This model is a direct parallel to the stated project. The deployed "Protocol Adaptors" (PAs) are a concrete implementation of Anoma's "Protocol Adapters," which serve as translators to connect Anoma's system with existing blockchains.[36, 37, 38, 39, 40, 8, 41, 42, 16] The DApp's "state (resources)" that "live across different network controllers" maps precisely to Anoma's "Resource Machine" (ARM) model.[38, 43, 44, 4, 45, 46, 47]</p>
        <p>In this framework, the project is building a heterogeneous, multi-controller system using EVM components:</p>
        <ul>
            <li><code>Controller_ETH</code>: The Ethereum L1.</li>
            <li><code>Controller_Base</code>: The Base L2.</li>
            <li><code>Controller_Arb1</code>: The Arbitrum L2.</li>
        </ul>
        <p>The core requirement—for the Ethereum PA to "check that Base state has changed"—is a request for a "resource transfer" between controllers.</p>

        <h3>1.2 The Controller Label Model as a Cross-Chain Specification</h3>
        <p>The Anoma research paper "Cross-Chain Integrity with Controller Labels and Endorsement" provides a formal model for this exact problem.[48, 49, 39, 8, 50, 51, 35, 52, 9]</p>
        <p>In this model, every "resource" (a "mutable digital object") is "labeled with a controller identifier, whose state is definitive for this resource".[48] For example, a token existing on the Base PA is a resource with the label <code>Controller_Base</code>.</p>
        <p>When a resource moves from <code>Controller_Base</code> to <code>Controller_ETH</code>, its label must change. This "resource controller operation" requires "endorsement".[48] The "endorsement" is the act of <code>Controller_ETH</code> (the L1 PA) formally accepting the validity of the state transition that occurred on <code>Controller_Base</code> (e.g., the burning of the token on L2).</p>
        <p>The central technical challenge is designing the "endorsement algorithm" for our custom GMP. This is the <em>trust model</em> the L1 PA will use to verify L2 state. The following sections specify three distinct models for this algorithm.</p>

        <h2>2. Attestation Models for L2-to-L1 Endorsement (The "GMP")</h2>
        <p>This section details the "withdrawal" flow, specifying the algorithms for the L1 PA (<code>Controller_ETH</code>) to endorse a state change from an L2 PA (<code>Controller_Base</code> or <code>Controller_Arb1</code>). We are not required to use the native bridges, but in building our own GMP, we are building our own bridge and must choose one of the following trust models.</p>

        <h3>2.1 Model A: Optimistic Endorsement (Trusts L1 Bridge Oracles)</h3>
        <p>This model is trustless and relies on the rollup's native crypto-economic security.</p>
        <ul>
            <li><strong>The Mechanism:</strong> The L1 PA, as an on-chain contract, cannot derive L2 state from L1 DA. Its <em>only</em> trustless, on-chain source of L2 state is the L1 bridge oracle contract.
                <ul>
                    <li><strong>Base (OP Stack):</strong> The <code>L2OutputOracle</code>.[3, 6, 42, 4, 53, 54, 55, 56, 52, 57]</li>
                    <li><strong>Arbitrum (Nitro):</strong> The <code>Outbox</code> and <code>Rollup</code> contracts.[58, 49, 59, 60, 61, 23, 62]</li>
                </ul>
            </li>
            <li><strong>The Finality:</strong> These oracle contracts <em>enforce</em> the ~7-day challenge period.[58, 7, 8, 25, 60, 22] The L1 PA <em>must</em> wait for the state root to be marked as "finalized" by this oracle before accepting any MPT proof against it.</li>
            <li><strong>Implementation:</strong> A GMP relayer would query the <code>L2OutputOracle</code> for a finalized root, generate an MPT proof for the L2 PA's state change (see Section 4), and submit this proof to the L1 PA.</li>
            <li><strong>Pros:</strong> Fully trustless; relies on the battle-tested security of the rollup itself.</li>
            <li><strong>Cons:</strong> Slow. The 7-day finality period is a major UX and capital efficiency drawback.</li>
        </ul>

        <h3>2.2 Model B: ZK Endorsement (Trusts zkVM Execution)</h3>
        <p>This model replaces the time-based optimistic finality with mathematical validity of <em>PA execution</em>.</p>
        <ul>
            <li><strong>The Mechanism:</strong> The L2 PA executes its state change (e.g., "burn resource") <em>inside</em> the Risc0 zkVM.[33, 34, 9] This proves that the PA's <em>specific logic</em> ran correctly. This produces a ZK proof and a "journal" (public outputs) containing the state change commitment.</li>
            <li><strong>The Finality:</strong> The ZK proof provides <em>instant mathematical finality</em> for the PA's execution.</li>
            <li><strong>Implementation:</strong> A GMP relayer submits this ZK proof directly to the L1 PA. The L1 PA's "endorsement" function is a call to the Risc0 verifier contract.[5, 10, 63, 64, 65, 66, 67]</li>
            <li><strong>Pros:</strong> Instant finality.</li>
            <li><strong>Cons:</strong>
                <ol>
                    <li><strong>Liveness Risk:</strong> Proof generation relies on a "proof market" like Boundless Signal.[3, 11, 27, 28, 29, 68, 69] If this market fails or becomes unprofitable, our GMP halts.</li>
                    <li><strong>Governance Risk:</strong> The <code>RiscZeroVerifierRouter</code> contract is an upgradeable proxy managed by the Risc0 team.[5, 10] A compromise of their governance keys could allow an attacker to deploy a malicious verifier and forge proofs, draining the L1 PA.[10, 30]</li>
                </ol>
            </li>
        </ul>

        <h3>2.3 Model C: Attested Endorsement (Trusts Solvers + Hardware/ZK)</h3>
        <p>This is a highly advanced sovereign model that provides speed by attesting to the L2 sequencer feed, while using ZKPs and TEEs to minimize trust. This is ideal for intent-based solving.</p>
        <ul>
            <li><strong>The Mechanism:</strong> Our GMP is a permissionless network of "solvers" (or LPs) who compete to fill cross-chain intents. These solvers monitor the L2 <em>sequencer feed</em> (the "unsafe" state) for L2 PA actions.[29, 70, 35]</li>
            <li><strong>The Finality:</strong> The solver provides instant finality by fronting the capital (as in a fast bridge) and submitting an "attested endorsement" to the L1 PA. This attestation is a bundle of proofs.</li>
            <li><strong>Implementation:</strong> To fill an intent, a solver calls the L1 PA with:
                <ol>
                    <li><strong>A ZK Proof of State:</strong> The solver can use a ZK coprocessor [11, 68] or L2 state verifier to generate a ZK proof of the L2 state change (e.g., the burn). This proves <em>what</em> happened, instantly, replacing trust in the oracle's signature with trust in math.</li>
                    <li><strong>A TEE Attestation (e.g., Intel TDX):</strong> The solver's intent-matching logic runs inside a Trusted Execution Environment (TEE) like Intel TDX. This TEE provides a <em>remote attestation</em>—a hardware-signed proof that the solver ran the correct, untampered code. This protects the user's intent privacy and prevents the solver from front-running or maliciously filling the intent.</li>
                </ol>
            </li>
            <li><strong>The L1 PA's "endorsement" function</strong> becomes a multi-step verification:
                <ol>
                    <li><code>require(ZK_Verifier.verify(zk_state_proof))</code></li>
                    <li><code>require(TEE_Attestation_Verifier.verify(tdx_attestation, solver_code_hash))</code></li>
                </ol>
            </li>
            <li><strong>Pros:</strong>
                <ol>
                    <li><strong>Instant Finality:</strong> Bypasses the 7-day wait.</li>
                    <li><strong>Trust-Minimized:</strong> Replaces centralized oracle trust with trust in ZK math and verifiable hardware.</li>
                    <li><strong>Privacy & MEV-Resistance:</strong> Using TEEs for solving protects user intents from the solver and the underlying infrastructure.</li>
                </ol>
            </li>
            <li><strong>Cons:</strong>
                <ol>
                    <li><strong>Extreme Complexity:</strong> This is at the cutting edge of protocol design.</li>
                    <li><strong>Hardware Trust:</strong> The model now relies on the security of Intel TDX, which is not immune to sophisticated side-channel attacks.</li>
                    <li><strong>Liveness Risk:</strong> Still reliant on a network of solvers/provers.</li>
                </ol>
            </li>
        </ul>

        <h3>2.4 How to Choose: Attestation Depends on the Ledger of Record</h3>
        <p>The attestation choice is a critical security decision that depends on <em>what</em> is being bridged.</p>
        <ul>
            <li><strong>Case 1: Bridging L1-Native Resources</strong> (L1 PA is the Ledger of Record)<br>
                If the L1 PA locks 100 ETH and mints 100 L2-ETH, the L1 PA is the "ledger of record" for the underlying collateral. In this case, we <strong>cannot use the simple version of Model C</strong> (trusted oracles). As the "sovereign rollup" article notes, if the L2 social consensus forks, the L1 PA <em>must</em> follow the canonical L1 bridge (Optimism Classic) to protect the collateral.
                <ul>
                    <li><strong>Recommendation:</strong> We <em>must</em> use <strong>Model A</strong> (slow, secure) or <strong>Model B</strong> (fast, ZK-secure).</li>
                </ul>
            </li>
            <li><strong>Case 2: Bridging L2-Native Resources</strong> (L2 PA is the Ledger of Record)<br>
                If the L2 PA mints a <em>new</em> sovereign resource (e.g., <code>$L2_TOKEN</code>), and the L1 PA is just creating a "wrapped" version, the L2 PA is the ledger of record. The L1 PA holds no collateral.
                <ul>
                    <li><strong>Recommendation:</strong> We are free to use any model. The advanced <strong>Model C (Attested)</strong> is a perfect fit here, as it "endorses" the L2's sovereign state with verifiable, privacy-preserving proofs.</li>
                </ul>
            </li>
            <li><strong>Application Layer (Fast Bridge):</strong> As noted, a "fast bridge" application can be built <em>on top</em> of the protocol. This is an ideal architecture:
                <ol>
                    <li><strong>Protocol Layer (PAs):</strong> Use <strong>Model A</strong> (slow, trustless) for L1-native assets.</li>
                    <li><strong>Service Layer (Solvers/LPs):</strong> Off-chain solvers build a <strong>Model C</strong> service. They "trust" the sequencer feed to give users instant funds, while they (the LPs) use the protocol's slow Model A in the background to rebalance their liquidity.</li>
                </ol>
            </li>
        </ul>

        <h2>3. L1-to-L2 State Access: The Fundamental Asymmetry</h2>
        <p>This section details the "deposit" flow, specifying the algorithm for an L2 PA (e.g., <code>Controller_Base</code>) to endorse a state change from the L1 PA (<code>Controller_ETH</code>).</p>

        <h3>3.1 The Fundamental Asymmetry of L1/L2 Attestation</h3>
        <p>A critical and counter-intuitive architectural constraint prevents the L2-to-L1 attestation model from being reused in reverse. L2 rollups are <em>derived</em> from L1 data.[25, 54, 31, 71, 72]</p>
        <p>However, the specific data exposed to L2 smart contracts is limited. Table 2 summarizes the key precompiles available to L2 contracts for reading L1 data.</p>
        
        <p><strong>Table 1: L1-Data-on-L2 Access Mechanisms (Precompiles)</strong></p>
        <table>
            <thead>
                <tr>
                    <th>Stack</th>
                    <th>Precompile Contract</th>
                    <th>L2 Address</th>
                    <th>Key Function(s)</th>
                    <th>Data / Security Model</th>
                    <th>Source(s)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>OP Stack (Base)</td>
                    <td><code>L1Block</code></td>
                    <td><code>0x42...0015</code></td>
                    <td><code>number()</code>, <code>timestamp()</code>, <code>basefee()</code>, <code>hash()</code></td>
                    <td>Provides L1 <em>block attributes</em> (number, timestamp, basefee, hash) as of the <em>start</em> of the L2 block's epoch. Securely provided by L2 node derivation.</td>
                    <td>[73, 4, 74, 75]</td>
                </tr>
                <tr>
                    <td>Arbitrum</td>
                    <td><code>ArbSys</code></td>
                    <td><code>0x00...0064</code></td>
                    <td><code>getL1BlockNumber()</code></td>
                    <td>Provides L1 <em>block number</em>. Securely provided by L2 node derivation.</td>
                    <td>[58, 24, 76, 77, 78, 79, 80]</td>
                </tr>
            </tbody>
        </table>

        <p>As Table 1 demonstrates, neither rollup stack exposes the L1 <strong><code>stateRoot</code></strong> to the L2 EVM.[37, 1, 2] The L2 PA <em>cannot</em> access the L1 state root. Therefore, it is <em>impossible</em> for the L2 PA to "hardcode" the MPT verification algorithm from Section 4 to check the L1 PA's state.</p>
        <p>This asymmetry is a known challenge in L2 design.[81] The L2 PA cannot "check" L1 state; it must be "told" the L1 state through a secure channel.</p>

        <h3>3.2 Secure Attestation from L2 to L1: The Deposit/Messaging Flow</h3>
        <p>The only trustless mechanism for L1-to-L2 state attestation is to use the native L1-to-L2 bridge, which provides a proof of <em>origin</em>.</p>
        
        <h4>The Attestation Algorithm (L1-to-L2)</h4>
        <ol>
            <li>The L1 PA (on Ethereum) initiates a resource transfer by calling the native L1 bridge contract, passing the new state data as calldata.
                <ul>
                    <li><strong>On Base:</strong> The L1 PA calls the <code>OptimismPortal.createDepositTransaction(...)</code>.[3, 32, 5, 4]</li>
                    <li><strong>On Arbitrum:</strong> The L1 PA calls the <code>Inbox.createRetryableTicket(...)</code>.</li>
                </ul>
            </li>
            <li>The L2 rollup node reads this L1 transaction and <em>derives</em> a corresponding L2 transaction from it.[25, 54, 31, 71]</li>
            <li>This derived L2 transaction is executed on L2, calling the L2 PA.</li>
            <li><strong>Attestation:</strong> The L2 PA's "endorsement" function verifies the <code>msg.sender</code>. The native bridge <em>aliases</em> the L1 PA's address. The L2 PA simply checks <code>require(msg.sender == ALIASED_L1_PA_ADDRESS)</code>.[32, 5]</li>
        </ol>
        <p>This mechanism is secure because the L2 transaction's <code>msg.sender</code> is <em>guaranteed</em> by the L2's state transition function, which is itself derived from L1 consensus. The L2 PA implicitly trusts the L1 state by trusting the bridge's aliasing mechanism.</p>

        <h3>3.3 Future Mechanisms: <code>L1SLOAD</code> Precompile</h3>
        <p>This entire architectural asymmetry may be resolved in the future. RIP 7728 proposes a new <code>L1SLOAD</code> precompile that would allow L2 contracts to <em>directly read L1 storage slots</em>.[82, 81] If this is implemented, the L2 PA <em>could</em> then directly "check" the L1 PA's state, enabling a symmetric attestation model. However, any system built today must use the message-based model from Section 3.2.</p>

        <h2>4. A Practical Algorithm for "Hardcoded" State Attestation (Model A Internals)</h2>
        <p>This section provides the end-to-end algorithm for an L1 PA to verify an arbitrary state variable of an L2 PA <em>after</em> it has received a finalized L2 state root from the L1 bridge oracle (i.e., the technical implementation of <strong>Model A</strong>).</p>

        <h3>4.1 Step 1 (Off-Chain): Deterministic State Fetching</h3>
        <p>To generate a proof, the off-chain relayer must first determine the MPT <code>key</code> for the specific state variable within the target L2 PA contract. This <code>key</code> is the variable's <em>storage slot</em>, which is deterministic.[11, 12, 13]</p>
        <ul>
            <li><strong>Simple Variables:</strong> For fixed-size state variables (e.g., <code>uint256</code>), the slot is their order of definition in the contract code, starting from slot 0.[11, 12, 13]</li>
            <li><strong>Mappings:</strong> For a mapping (e.g., <code>mapping(address => uint256) public balances;</code> at slot 3), the storage slot for a <em>specific entry</em> (e.g., <code>balances[0xabc...]</code>) is calculated as <code>keccak256(abi.encodePacked(key, slot))</code>.[11, 15, 61, 2]</li>
        </ul>
        <p>This deterministic <code>key</code> (the 32-byte storage slot) is the first required input for the proof.</p>

        <h3>4.2 Step 2 (Off-Chain): Proof Generation</h3>
        <p>The off-chain relayer, having identified the <code>storageSlot</code> (key) and the <code>blockNumber</code> corresponding to a <em>finalized</em> state root, must query a full node of the target L2 chain.</p>
        <p>The JSON-RPC method <code>eth_getProof</code> (EIP-1186) is used for this purpose.[11, 14, 53, 83, 12, 15, 84, 13, 16, 61, 85, 2]</p>
        <ul>
            <li><strong>RPC Call:</strong> <code>eth_getProof(contractAddress, , blockNumber)</code></li>
            <li><strong>Response:</strong> The node returns a JSON object containing the <code>storageProof</code>. This <code>storageProof</code> data is the second required input for on-chain verification.</li>
        </ul>

        <h3>4.3 Step 3 (On-Chain): "Hardcoded" Proof Verification</h3>
        <p>The verifying L1 PA must import a Solidity MPT verifier library. Several open-source implementations exist.[32, 17, 25, 4, 84, 18, 19, 20, 21, 27, 81, 22, 23, 85, 86, 87, 26, 88, 89, 90, 91]</p>
        <p>The following Solidity pseudocode provides the algorithm for the L1 PA to verify a state variable on the Base PA.</p>
        
<pre><code>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Imports a trusted MPT verifier library
import {MerklePatriciaProofVerifier} from "@limechain/extractoor-contracts/MPT.sol"; [17, 22]
// Imports the L2OutputOracle interface
import {IL2OutputOracle} from "@optimism/L1/IL2OutputOracle.sol"; [3, 4]

contract L1_ProtocolAdaptor {
    IL2OutputOracle public immutable oracle;
    uint256 public constant FINALIZATION_PERIOD_SECONDS = 7 days;
    address public immutable l2_pa_address;

    constructor(address _oracle, address _l2_pa_address) {
        oracle = IL2OutputOracle(_oracle);
        l2_pa_address = _l2_pa_address;
    }

    /**
     * @notice This is the "hardcoded" attestation function for Model A.
     * @param _l2BlockNumber The L2 block number of the state change.
     * @param _l2StorageSlot The deterministic key from Step 1 (Sec 4.1).
     * @param _mptProof The storageProof data from Step 2 (Sec 4.2).
     */
    function attestBaseStateAndClaimResource(
        uint256 _l2BlockNumber,
        bytes32 _l2StorageSlot,
        bytes calldata _mptProof
    ) public {
        
        // 1. Get the L2 output proposal from the L1 oracle
        uint256 l2OutputIndex = oracle.getL2OutputIndexAfter(_l2BlockNumber);
        Types.OutputProposal memory proposal = oracle.getL2Output(l2OutputIndex);
        
        // This is the finalized L2 state root
        bytes32 l2StateRoot = proposal.outputRoot; 

        // 2. ATTEST TO FINALITY (Answers Question 3)
        // Check that the challenge period has passed.
        // This is the most critical security check.
        require(
            block.timestamp > proposal.timestamp + FINALIZATION_PERIOD_SECONDS,
            "State is not finalized"
        );
        
        // 3. ATTEST TO STATE (Answers Question 2)
        // Verify the MPT proof against the finalized state root.
        (bool isValid, bytes memory value) = MerklePatriciaProofVerifier.verifyStorageProof(
            l2StateRoot, 
            _mptProof, 
            l2_pa_address,
            _l2StorageSlot
        );
        
        require(isValid, "Invalid MPT proof");
        
        // 4. Use the verified state
        // The 'value' is the RLP-decoded storage value.
        uint256 resourceCount_L2 = abi.decode(value, (uint256));
        
        // Example: check that the L2 resource was burned (count is 0)
        require(resourceCount_L2 == 0, "L2 resource not burned");
        
        // 5. Endorse the state change by minting the resource on L1
        _mintResource(msg.sender);
    }
    
    function _mintResource(address _to) internal {
        //... L1 minting logic
    }
}
</code></pre>

        <h3>4.4 Security Analysis: The MPT "Empty Proof" Vulnerability</h3>
        <p>This algorithm is critically dependent on the security of the imported MPT verifier library. A severe flaw was discovered in widely used MPT verifier implementations.[24, 25, 69, 26]</p>
        <ul>
            <li><strong>The Vulnerability:</strong> The flaw allowed a "forged proof of exclusion." An attacker could submit a specially crafted <em>empty</em> proof, and the vulnerable verifier would <em>incorrectly</em> return <code>isValid = true</code> and <code>value = 0x</code> (empty bytes).[24, 25, 69]</li>
            <li><strong>The Attack:</strong> This would trick the protocol into believing that a storage slot was uninitialized (i.e., its value was <code>0</code>).[25] In the pseudocode above, an attacker could use this vulnerability to pass the <code>require(resourceCount_L2 == 0)</code> check <em>even if the L2 resource was never burned</em>. This would allow them to mint resources on L1 for free.</li>
        </ul>
        <p>Any implementation of this "hardcoded" algorithm <em>must</em> use an MPT verifier library that has been explicitly audited and patched against this "empty proof" forgery attack.[24, 25, 69]</p>

        <h2>5. Conclusions and Recommendations</h2>
        <p>This report has specified the technical algorithms for bidirectional, provable state attestation between L1 and L2 Protocol Adaptors. The following recommendations are provided for the "sovereign controller" GMP implementation.</p>
        <ol>
            <li><strong>Choose The Attestation Model Based on The Ledger of Record:</strong> This is the most critical design decision.
                <ul>
                    <li><strong>If the L1 PA is the ledger of record</strong> (e.g., for L1-native collateral), we <em>must</em> use a trustless model. The options are <strong>Model A</strong> (slow, 7-day finality via <code>L2OutputOracle</code>) or <strong>Model B</strong> (fast, ZK-based via Risc0). The simple version of Model C is <em>not</em> a safe option for the core protocol.</li>
                    <li><strong>If the L2 PA is the ledger of record</strong> (e.g., for L2-native resources), we are free to "endorse" the L2's sovereign state. <strong>Model C (Attested)</strong> is an excellent, advanced choice here, providing speed with verifiable security guarantees from ZKPs and TEEs.</li>
                </ul>
            </li>
            <li><strong>Architect for L1-to-L2 Asymmetry:</strong> The L2 PAs <em>must</em> be architected to <em>receive</em> state from L1, not <em>check</em> L1 state. The "endorsement" algorithm for the L2 PA is a simple <code>require(msg.sender == ALIASED_L1_PA_ADDRESS)</code> check, which relies on the security of the native L1-to-L2 message bridge.[32, 5]</li>
            <li><strong>Layer The "Fast Bridge":</strong> As noted, the best UX is to build a "fast bridge" application <em>on top</em> of the controllers protocol. This creates a robust, two-tiered system:
                <ul>
                    <li><strong>Protocol Layer:</strong> Secures L1-native assets using the slow, trustless <strong>Model A</strong>.</li>
                    <li><strong>Service Layer:</strong> A permissionless network of solvers/LPs provides an instant "fast bridge" (a simple <strong>Model C</strong> service). These solvers trust the sequencer feed [29, 35] to pay users instantly, while they use the protocol's Model A to rebalance their own liquidity in the background.</li>
                </ul>
            </li>
            <li><strong>Mitigate ZK Governance Risk:</strong> If we choose <strong>Model B</strong> (ZK Attestation) for its instant finality, we <em>must</em> mitigate the centralized governance risk of the <code>RiscZeroVerifierRouter</code>.[5, 10] It is recommended to wrap the router in our own circuit-breaker and governance mechanism that pauses the L1 PA if the router is upgraded without the DAO's approval.[31, 30]</li>
            <li><strong>Mandatory Audit for MPT Verifiers:</strong> If we implement <strong>Model A</strong>'s "hardcoded" verifier (Section 4), it <em>must</em> be audited by a reputable firm, with a specific focus on patching the "empty proof" vulnerability.[24, 25, 69, 26]</li>
        </ol>
        <p>Ultimately, the project is an EVM-native implementation of the Anoma cross-controller resource model.[48, 39, 9] The GMP (general message passing protocol) is our "endorsement" protocol, and its security will be defined by the trust model we choose.</p>
    </div>
</body>
</html>
